from abc import ABC, abstractmethod
import os
import yaml
import shutil
from .deployment_files import DOCKER_COMPOSE_FILENAME, CytomineEnvsFile, DockerComposeFile, EditableDockerCompose
from .deployment_files import DOCKER_COMPOSE_OVERRIDE_FILENAME
from .errors import InvalidServerConfigurationError
from ..util import list_relative_files, write_dotenv


class Deployable(ABC):
  @abstractmethod
  def deploy_files(self, target_directory):
    """Generates/transfers a set of files in the target directory."""
    pass

  @abstractmethod
  def clean_generated_files(self, target_directory):
    """Clean files generated by deploy_files"""
    pass

  @property
  @abstractmethod
  def source_files(self):
    """List (existing) source files"""
    pass

  @property
  def target_files(self):
    """List files that would be deployed by the Deployable (relative path)"""
    files = list()
    files.extend(self.source_files)
    files.extend(self.generated_files)
    return files

  @property
  @abstractmethod
  def generated_files(self):
    """List files that would be generated by the Deployable (relative path)"""
    pass


class ServerFolder(Deployable):
  def __init__(self, server_name, directory, envs: CytomineEnvsFile, configs_folder="configs", 
               envs_folder="envs", configs_mount_point="/cm_configs") -> None:
    """
    Parameters:
    -----------
    server_name: str
    directory: str
      Server directory path
    configs_folder: str
      Name of the configs folder
    envs_folder:
      Name of the target environment folder
    configs_mount_point:
      Name of the configuration target folder within the container 
    """
    self._server_name = server_name
    self._directory = directory
    self._configs_folder = configs_folder
    self._configs_mount_point = configs_mount_point
    self._envs_folder = envs_folder
    self._docker_compose_file = DockerComposeFile(directory)
    self._envs = envs

  @property 
  def directory(self):
    return self._directory

  @property
  def server_name(self):
    return self._server_name

  @property
  def has_config(self):
    return os.path.exists(self.configs_path)

  @property 
  def configs_path(self):
    return os.path.join(self._directory, self._configs_folder)

  @property
  def docker_compose_path(self):
    return os.path.join(self._directory, DOCKER_COMPOSE_FILENAME)

  @property
  def source_files(self):
    """List (existing) source files"""
    files = list()
    files.append(os.path.relpath(self._docker_compose_file.filepath, self._directory))
    config_files = list_relative_files(os.path.join(self._directory, self._configs_folder))
    for config_file in config_files:
      files.append(os.path.join(self._configs_folder, config_file)) 
    return    files

  @property
  def generated_files(self):
    target_files = list()
    target_files.append(".env")
    target_files.append(DOCKER_COMPOSE_OVERRIDE_FILENAME)
    for service in self._docker_compose_file.services:
      env_store = self._envs.server_store(self._server_name)
      if env_store.has_namespace(service):
        target_files.append(os.path.join(self._envs_folder, f"{service}.env"))
    return target_files

  def deploy_files(self, target_directory):
    """Generates a target server folder"""
    # docker-compose
    shutil.copyfile(
      self._docker_compose_file.filepath,
      os.path.join(target_directory, self._docker_compose_file.filename)
    )

    # .env file
    global_envs = dict()
    for namespace in self._envs.global_envs.namespaces:
      ns_envs = self._envs.global_envs.get_namespace_envs(namespace)
      global_envs.update({f"{namespace.upper()}_{key.upper()}": value for key, value in ns_envs.items()})
    write_dotenv(target_directory, global_envs)

    # docker-compose.override.yml
    override_file = EditableDockerCompose(version=self._docker_compose_file.version)

    # envs/{SERVICE}.env files 
    target_envs = os.path.join(target_directory, self._envs_folder)
    os.makedirs(target_envs)
    for service in self._docker_compose_file.services:
      env_store = self._envs.server_store(self._server_name)
      if not env_store.has_namespace(service):
        continue
      service_envs = env_store.get_namespace_envs(service)
      env_filepath = write_dotenv(target_envs, service_envs, filename=f"{service}.env")
      override_file.set_service_env_file(service, os.path.relpath(env_filepath, target_directory))
    
    # configs
    for service in self._docker_compose_file.services:
      src_service_configs_path = os.path.join(self._directory, self._configs_folder, service)
      if os.path.exists(src_service_configs_path):
        target_config_relpath = os.path.join(self._configs_folder, service)
        override_file.add_service_volume(service, f"./{target_config_relpath}:{self._configs_mount_point}")

    shutil.copytree(
      os.path.join(self._directory, self._configs_folder),
      os.path.join(target_directory, self._configs_folder)
    )

    # save override
    override_file.write_to(target_directory, DOCKER_COMPOSE_OVERRIDE_FILENAME)

    return target_directory
  
  def clean_generated_files(self, target_directory):
    for file_to_remove in self.generated_files:
      file_path = os.path.join(target_directory, file_to_remove)
      if not os.path.exists(file_path):
        continue
      os.remove(file_path)
      try:
        os.removedirs(os.path.dirname(file_path))
      except OSError:
        pass

    # double-check 'envs' folder
    envs_folder = os.path.join(self._directory, self._envs_folder)
    if os.path.isdir(envs_folder):
      os.rmdir(envs_folder)
      
class DeploymentFolder(Deployable):
  SERVER_DEFAULT = "default"

  def __init__(self, directory="/bootstrap", cytomine_envs_filename="cytomine.yml", 
               configs_folder="configs", envs_folder="envs", ignored_dirs=None, 
               configs_mount_point="/cm_configs") -> None:
    """
    Parameters
    ----------
    directory: str
      Path of the directory where cytomine.yml is stored
    cytomine_envs_filename: str
      Name of the cytomine environment variables file
    configs_folder: str
      Name of the configs folder in each server folder
    envs_folder: str
      Name of the target environment folder in the target server folder
    ignored_folders: set|list|NoneType
      Folders to ignore in the root directory
    configs_mount_point :
      Name of the configuration files mount path within the container 
    """
    if ignored_dirs is None:
      ignored_dirs = set()

    self._directory = directory
    self._ignore_dirs = set(ignored_dirs)
    self._configs_folder = configs_folder
    self._envs_folder = envs_folder
    self._configs_mount_point = configs_mount_point
    self._cytomine_envs_filename = cytomine_envs_filename
    self._envs = CytomineEnvsFile(path=self._directory, filename=self._cytomine_envs_filename)

    self._server_folders = dict()
    _, subdirs, subfiles = next(os.walk(self._directory))
    self._subdirs = set(subdirs).difference(self._ignore_dirs)

    ## checking server configuration (single or multi-server?)  
    # we are in single-server mode if a docker-compose file is at the root
    self._single_server = DOCKER_COMPOSE_FILENAME in subfiles

    nb_servers_in_envs = len(self._envs.servers) 
    if self._single_server and nb_servers_in_envs > 1:
      raise InvalidServerConfigurationError(
        f"it appears to be a single-server configuration ({DOCKER_COMPOSE_FILENAME} found in root directory) but several server entries have been found in cytomine.yml"
      )
    elif not self._single_server:
      envs_servers = set(self._envs.servers)
      folder_servers = self._subdirs
      if not envs_servers.issubset(folder_servers):
        raise InvalidServerConfigurationError(
          f"it appears to be a multi-server configuration ({DOCKER_COMPOSE_FILENAME} not found in root directory) but some server entries in cytomine.yml have no matching server folder"
        )

    server_folder_common_params = {
      "configs_folder": self._configs_folder,
      "envs_folder": self._envs_folder,
      "configs_mount_point": self._configs_mount_point
    }

    if self._single_server:
      # single server
      self._server_folders[self.SERVER_DEFAULT] = ServerFolder(
        server_name=self.SERVER_DEFAULT,
        directory=self._directory,
        envs=self._envs,
        **server_folder_common_params
      )
    else:    
      for subdir in self._subdirs:
        self._server_folders[subdir] = ServerFolder(
          server_name=subdir,
          directory=os.path.join(self._directory, subdir),
          envs=self._envs,
          **server_folder_common_params
        )

  @property
  def is_single_server(self):
    return self._single_server

  @property
  def server_folders(self):
    return self._server_folders

  def deploy_files(self, target_directory):
    dst_cytomine_envs_path = os.path.join(target_directory, self._envs.filename)
    with open(dst_cytomine_envs_path, "w", encoding="utf8") as file:
      yaml.dump(self._envs.export_dict(), file)
    
    for server_folder in self._server_folders.values():
      if self._single_server:
        server_target_dir = target_directory
      else:
        server_target_dir = os.path.join(target_directory, server_folder.server_name)
        os.makedirs(server_target_dir)
      server_folder.deploy_files(server_target_dir)

  def clean_generated_files(self, target_directory):
    # clean target server folders to get back to a clean 
    # deployable deployment folder
    for server_folder in self._server_folders.values():
      server_folder.clean_generated_files(target_directory)

  def _abs_to_relative(self, src_dir, files, ref_dir):
    return [os.path.relpath(os.path.join(src_dir, file), ref_dir) for file in files]
  
  @property
  def source_files(self):
    """List (existing) source files"""
    files = [
      self._cytomine_envs_filename
    ]

    for server_folder in self._server_folders.values():
      files.extend(self._abs_to_relative(
        src_dir=server_folder.directory, 
        files=server_folder.source_files,
        ref_dir=self._directory 
      ))

    return files

  @property
  def generated_files(self):
    files = list()
    for server_folder in self._server_folders.values():
      files.extend(self._abs_to_relative(
        src_dir=server_folder.directory, 
        files=server_folder.generated_files,
        ref_dir=self._directory 
      ))
    return files